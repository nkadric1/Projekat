package ba.unsa.etf.rpr.business;

import ba.unsa.etf.rpr.dao.DaoFactory;
import ba.unsa.etf.rpr.dao.EmployeeDAOSQLImpl;
import ba.unsa.etf.rpr.domain.Departments;
import ba.unsa.etf.rpr.domain.Employee;
import ba.unsa.etf.rpr.domain.Project;
import ba.unsa.etf.rpr.exceptions.EmployeeException;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.mockito.Mockito.when;

public class EmployeeManagerTest {
    private EmployeeManager employeeManager;
    private Employee e;
    private EmployeeDAOSQLImpl employeeDAOSQL;
    private List<Employee> employees;

    @BeforeEach
    public void initializeObj(){
        employeeManager=Mockito.mock(EmployeeManager.class);
        e=new Employee();
        e.setId(1);
        e.setFirst_name("Ivana");
        e.setLast_name("Marc");
        e.setAddress("street5.B");
        e.setHire_date(LocalDate.now());
        e.setPayoff(1000);
        e.setEdu("Bachelor");
        Project p=new Project();
        p.setId(200);
        e.setProject(p);
        Departments d=new Departments();
        d.setId(30);
        e.setDepartment(d);
        employeeDAOSQL=Mockito.mock(EmployeeDAOSQLImpl.class);
        employees=new ArrayList<>();
        employees.addAll(Arrays.asList(new Employee("Zana","Jack","street22.D",LocalDate.now(),new Departments(30),new Project(202),"Master",2000),
                new Employee("Clare","Jade","street25.D",LocalDate.now(),new Departments(20),new Project(202),"Master",2000)));

    }
    @Test
    void validName() throws EmployeeException {

        String n1 = "Zana";
        try {
            Mockito.doCallRealMethod().when(employeeManager).validName(n1);
        } catch (EmployeeException e) {
            e.printStackTrace();
            Assertions.assertTrue(false);
        }
        String incorrectn = "A";
        Mockito.doCallRealMethod().when(employeeManager).validName(incorrectn);
      EmployeeException ex=Assertions.assertThrows(EmployeeException.class, () -> {
            employeeManager.validName(incorrectn);
        }, "Name of employee must be between 2 and 45 chars");
        Assertions.assertEquals("Name of employee must be between 2 and 45 chars", ex.getMessage());

        String inc = RandomStringUtils.randomAlphabetic(60);
        Mockito.doCallRealMethod().when(employeeManager).validName(inc);
      EmployeeException exc=Assertions.assertThrows(EmployeeException.class, () -> {
            employeeManager.validName(inc);
        }, "Name of employee must be between 2 and 45 chars");
        Assertions.assertEquals("Name of employee must be between 2 and 45 chars", exc.getMessage());

    }
    @Test
    void add() throws EmployeeException{
        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDAOSQL);
      when(DaoFactory.employeeDao().getAll()).thenReturn(employees);
   Mockito.doCallRealMethod().when(employeeManager).add(e);
   EmployeeException emp=Assertions.assertThrows(EmployeeException.class,()->{employeeManager.add(e);},"ID is autogenerated. Cannot add department.");
   Assertions.assertEquals("ID is autogenerated. Cannot add department.", emp.getMessage());
        daoFactoryMockedStatic.verify(DaoFactory::employeeDao);
        Mockito.verify(employeeManager).add(e);
        daoFactoryMockedStatic.close();
        }
        @Test
    void addNewEmp() throws EmployeeException{
        Employee e=new Employee("Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
        EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);
        when(employeeDao.add(e)).thenReturn(e);
        employeeManager.add(e);
        Assertions.assertTrue(true);
        daoFactoryMockedStatic.close();
        }
        @Test
    void UpdateEmp() throws  EmployeeException{
            Employee e=new Employee(55,"Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
            e.setId(0);
            e.setEdu("Master");
            MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
            EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
            daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);
            when(employeeDao.update(e)).thenReturn(e);
            employeeManager.update(e);
            Assertions.assertTrue(true);
            daoFactoryMockedStatic.close();
        }
        @Test
        void DeleteEmp() throws EmployeeException{
            Employee e=new Employee("Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
            e.setEdu("Master");
            MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
            EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
            daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);
            employeeManager.delete(e.getId());
            Assertions.assertTrue(true);
            daoFactoryMockedStatic.close();
        }
    }


